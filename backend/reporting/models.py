"""
Advanced reporting models for MigrateIQ.
"""

from django.db import models
from django.contrib.auth import get_user_model
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
# from django.core.validators import JSONSchemaValidator  # Not available in Django 4.2
import uuid
import json

User = get_user_model()


class ReportTemplate(models.Model):
    """Model for report templates."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    tenant = models.ForeignKey(
        'core.Tenant',
        on_delete=models.CASCADE,
        related_name='report_templates',
        verbose_name=_('Tenant')
    )

    name = models.CharField(_('Name'), max_length=200)
    description = models.TextField(_('Description'), blank=True)

    # Template configuration
    report_type = models.CharField(
        _('Report Type'),
        max_length=50,
        choices=[
            ('user_activity', _('User Activity')),
            ('project_summary', _('Project Summary')),
            ('migration_performance', _('Migration Performance')),
            ('data_quality', _('Data Quality')),
            ('system_health', _('System Health')),
            ('compliance', _('Compliance')),
            ('custom', _('Custom')),
        ]
    )

    # Data sources and filters
    data_sources = models.JSONField(
        _('Data Sources'),
        default=list,
        help_text=_('List of data sources for the report')
    )

    filters = models.JSONField(
        _('Filters'),
        default=dict,
        help_text=_('Default filters for the report')
    )

    # Visualization configuration
    chart_config = models.JSONField(
        _('Chart Configuration'),
        default=dict,
        help_text=_('Chart and visualization settings')
    )

    # Columns and metrics
    columns = models.JSONField(
        _('Columns'),
        default=list,
        help_text=_('Report columns configuration')
    )

    metrics = models.JSONField(
        _('Metrics'),
        default=list,
        help_text=_('Calculated metrics for the report')
    )

    # Access control
    is_public = models.BooleanField(
        _('Is Public'),
        default=False,
        help_text=_('Whether this template is available to all users in the tenant')
    )

    created_by = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='created_report_templates',
        verbose_name=_('Created By')
    )

    # Timestamps
    created_at = models.DateTimeField(_('Created at'), auto_now_add=True)
    updated_at = models.DateTimeField(_('Updated at'), auto_now=True)

    class Meta:
        verbose_name = _('Report Template')
        verbose_name_plural = _('Report Templates')
        ordering = ['name']
        indexes = [
            models.Index(fields=['tenant', 'report_type']),
            models.Index(fields=['created_by']),
        ]

    def __str__(self):
        return f"{self.name} ({self.tenant.name})"


class Report(models.Model):
    """Model for generated reports."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    tenant = models.ForeignKey(
        'core.Tenant',
        on_delete=models.CASCADE,
        related_name='reports',
        verbose_name=_('Tenant')
    )

    name = models.CharField(_('Name'), max_length=200)
    description = models.TextField(_('Description'), blank=True)

    # Template reference
    template = models.ForeignKey(
        ReportTemplate,
        on_delete=models.SET_NULL,
        related_name='generated_reports',
        verbose_name=_('Template'),
        null=True,
        blank=True
    )

    # Report configuration (snapshot of template at generation time)
    config = models.JSONField(
        _('Configuration'),
        default=dict,
        help_text=_('Report configuration snapshot')
    )

    # Report data
    data = models.JSONField(
        _('Report Data'),
        default=dict,
        help_text=_('Generated report data')
    )

    # Generation details
    generated_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        related_name='generated_reports',
        verbose_name=_('Generated By'),
        null=True,
        blank=True
    )

    # Time period
    period_start = models.DateTimeField(_('Period Start'), null=True, blank=True)
    period_end = models.DateTimeField(_('Period End'), null=True, blank=True)

    # Status
    status = models.CharField(
        _('Status'),
        max_length=20,
        choices=[
            ('pending', _('Pending')),
            ('generating', _('Generating')),
            ('completed', _('Completed')),
            ('failed', _('Failed')),
        ],
        default='pending'
    )

    error_message = models.TextField(_('Error Message'), blank=True)

    # File export
    export_format = models.CharField(
        _('Export Format'),
        max_length=10,
        choices=[
            ('json', _('JSON')),
            ('csv', _('CSV')),
            ('xlsx', _('Excel')),
            ('pdf', _('PDF')),
        ],
        default='json'
    )

    file_path = models.CharField(_('File Path'), max_length=500, blank=True)
    file_size = models.PositiveIntegerField(_('File Size (bytes)'), null=True, blank=True)

    # Timestamps
    created_at = models.DateTimeField(_('Created at'), auto_now_add=True)
    completed_at = models.DateTimeField(_('Completed at'), null=True, blank=True)

    class Meta:
        verbose_name = _('Report')
        verbose_name_plural = _('Reports')
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['tenant', 'status']),
            models.Index(fields=['generated_by']),
            models.Index(fields=['created_at']),
        ]

    def __str__(self):
        return f"{self.name} ({self.status})"


class ScheduledReport(models.Model):
    """Model for scheduled reports."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    tenant = models.ForeignKey(
        'core.Tenant',
        on_delete=models.CASCADE,
        related_name='scheduled_reports',
        verbose_name=_('Tenant')
    )

    name = models.CharField(_('Name'), max_length=200)
    description = models.TextField(_('Description'), blank=True)

    # Template reference
    template = models.ForeignKey(
        ReportTemplate,
        on_delete=models.CASCADE,
        related_name='scheduled_reports',
        verbose_name=_('Template')
    )

    # Schedule configuration
    schedule_type = models.CharField(
        _('Schedule Type'),
        max_length=20,
        choices=[
            ('daily', _('Daily')),
            ('weekly', _('Weekly')),
            ('monthly', _('Monthly')),
            ('quarterly', _('Quarterly')),
            ('custom', _('Custom')),
        ]
    )

    # Cron expression for custom schedules
    cron_expression = models.CharField(
        _('Cron Expression'),
        max_length=100,
        blank=True,
        help_text=_('Cron expression for custom schedules')
    )

    # Recipients
    recipients = models.JSONField(
        _('Recipients'),
        default=list,
        help_text=_('List of email addresses to send the report to')
    )

    # Export settings
    export_formats = models.JSONField(
        _('Export Formats'),
        default=list,
        help_text=_('List of export formats to generate')
    )

    # Status
    is_active = models.BooleanField(_('Is Active'), default=True)

    # Execution tracking
    last_run = models.DateTimeField(_('Last Run'), null=True, blank=True)
    next_run = models.DateTimeField(_('Next Run'), null=True, blank=True)
    run_count = models.PositiveIntegerField(_('Run Count'), default=0)

    created_by = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='created_scheduled_reports',
        verbose_name=_('Created By')
    )

    # Timestamps
    created_at = models.DateTimeField(_('Created at'), auto_now_add=True)
    updated_at = models.DateTimeField(_('Updated at'), auto_now=True)

    class Meta:
        verbose_name = _('Scheduled Report')
        verbose_name_plural = _('Scheduled Reports')
        ordering = ['name']
        indexes = [
            models.Index(fields=['tenant', 'is_active']),
            models.Index(fields=['next_run']),
        ]

    def __str__(self):
        return f"{self.name} ({self.schedule_type})"


class ReportShare(models.Model):
    """Model for sharing reports."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    report = models.ForeignKey(
        Report,
        on_delete=models.CASCADE,
        related_name='shares',
        verbose_name=_('Report')
    )

    # Sharing details
    shared_by = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='shared_reports',
        verbose_name=_('Shared By')
    )

    shared_with_email = models.EmailField(_('Shared With Email'), blank=True)
    shared_with_user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='received_report_shares',
        verbose_name=_('Shared With User'),
        null=True,
        blank=True
    )

    # Access control
    access_level = models.CharField(
        _('Access Level'),
        max_length=20,
        choices=[
            ('view', _('View Only')),
            ('download', _('View and Download')),
        ],
        default='view'
    )

    # Expiration
    expires_at = models.DateTimeField(_('Expires At'), null=True, blank=True)

    # Access tracking
    access_count = models.PositiveIntegerField(_('Access Count'), default=0)
    last_accessed = models.DateTimeField(_('Last Accessed'), null=True, blank=True)

    created_at = models.DateTimeField(_('Created at'), auto_now_add=True)

    class Meta:
        verbose_name = _('Report Share')
        verbose_name_plural = _('Report Shares')
        ordering = ['-created_at']

    def __str__(self):
        recipient = self.shared_with_user.email if self.shared_with_user else self.shared_with_email
        return f"{self.report.name} shared with {recipient}"

    def is_expired(self):
        """Check if share is expired."""
        if not self.expires_at:
            return False
        return timezone.now() > self.expires_at


class ReportMetric(models.Model):
    """Model for custom report metrics."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    tenant = models.ForeignKey(
        'core.Tenant',
        on_delete=models.CASCADE,
        related_name='report_metrics',
        verbose_name=_('Tenant')
    )

    name = models.CharField(_('Name'), max_length=100)
    description = models.TextField(_('Description'), blank=True)

    # Metric configuration
    metric_type = models.CharField(
        _('Metric Type'),
        max_length=20,
        choices=[
            ('count', _('Count')),
            ('sum', _('Sum')),
            ('average', _('Average')),
            ('min', _('Minimum')),
            ('max', _('Maximum')),
            ('percentage', _('Percentage')),
            ('custom', _('Custom')),
        ]
    )

    # Data source
    source_model = models.CharField(_('Source Model'), max_length=100)
    source_field = models.CharField(_('Source Field'), max_length=100, blank=True)

    # Calculation
    calculation = models.TextField(
        _('Calculation'),
        blank=True,
        help_text=_('Custom calculation expression')
    )

    # Filters
    filters = models.JSONField(
        _('Filters'),
        default=dict,
        help_text=_('Filters to apply when calculating the metric')
    )

    # Formatting
    format_string = models.CharField(
        _('Format String'),
        max_length=50,
        blank=True,
        help_text=_('Format string for displaying the metric value')
    )

    created_by = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='created_metrics',
        verbose_name=_('Created By')
    )

    created_at = models.DateTimeField(_('Created at'), auto_now_add=True)
    updated_at = models.DateTimeField(_('Updated at'), auto_now=True)

    class Meta:
        verbose_name = _('Report Metric')
        verbose_name_plural = _('Report Metrics')
        unique_together = [['tenant', 'name']]
        ordering = ['name']

    def __str__(self):
        return f"{self.name} ({self.tenant.name})"
